# Электронная система записи к врачам.

> Выбранный сервис для разбора - **«Электронная система записи к врачам»**.
> 
> Рассмотрим ее с учетом функциональных и нефункциональных требований, а также затронем подход к ее проектированию, масштабированию и тестированию.

---

## 1. Общая архитектура и контуры системы.

### 1.1 Архитектура микросервсисов.

Чтобы сделать систему гибкой и удобной для дальнейшего масштабирования, будем использовать **микросервисы**. Здесь их мжно выделить несколько!

1. **Account Service (Сервис «Управления учетными записями»).**  
   - Регистрация и аутентификация пользователей (пациенты, врачи, администраторы).  
   - Хранение базовых данных профиля: User_Name, Email, Phone, роль (Role_Patient, Role_Doctor, Role_Admin), права доступа, Registration_Date.

2. **Scheduling Service (Сервис «Расписания / Записи»).**  
   - Управление слотами для записи к врачам.  
   - Создание, перенос и отмена записей.  
   - Поддержка отстутствия конфликтов при записи (чтобы нельзя было занять один слот).

3. **Notifications Service (Сервис «Уведомлений»).**  
   - Отправка уведомлений о предстоящих приемах (Email, SMS, Push-уведомления).  
   - Настройка расписания рассылок, шаблонов уведомлений.

4. **Patient Card Service (Сервис «карточки пациента»).**  
   - Ведение медицинской истории пациента (приемы, диагнозы, рецепты).  
   - Контролируемый доступ (только врач с нужными правами может вносить изменения).  
   - Шифрование (медицинская тайна же у нас :) ).

5. **Payment Service (Если услуга платная).**  
   - Если в системе предполагается онлайн-оплата или учет оплат за консультации / приемы.

6. **API Gateway (Шлюз).**  
   - Общая точка входа для внешних клиентов (мобильное приложение или веб-интерфейс).  
   - Авторизация, маршрутизация запросов к нужным микросервисам.

7. **Admin Service.**
   - Управление расписаниями врачей, создание шаблонв расписания (например, «по вторникам — 10 доступных слотов»), администрирование пользователей и прочее.

---

## 2. Детали функциональных требований.

### 2.1 Регистрация пользователей (пациентов и врачей).

1. **Модели данных**  
   - **User** (сущность/агрегат):  
     - User_ID, Login, Password (в хэшированном виде),  
     - Роль (Role_Patient, Role_Doctor, Role_Admin),  
     - Профиль (User_Name, Email, Phone),  
     - Registration_Date.  
   - **Аутентификация**: JSON Web Token или OAuth2, чтобы обеспечить масштабируемость и единое место проверки токена.

2. **Ограничения**  
   - Уникальный Login / Phone / Email.  
   - Специальные требования для пароля (К примеру, наличие заглавных, строчных букв, цифр и специальных сервисов) 

### 2.2 Просмотр доступных слотов для записи.

1. **Слоты**  
   - Модель: Slot_ID, Start_Datetime, End_Datetime, Doctor_ID, Status (Свободен / Занят / Недоступен / Отменен).  
2. **Фильтрация**  
   - По Doctor_ID, по дате, по специализации врача (если есть), по локации (если врачи работают в разных местах).  
3. **Отображение**  
   - Может быть в календарном виде (UI-календарик) или в виде списка с доступными интервалами.

### 2.3 Создание, перенос и отмена записей.

1. **Создание записи**  
   - Пациент выбирает свободный слот, отправляет запрос на бронирование, система блокирует слот и создает запись (**Appointment**).  
   - **Appointment**:  
     - ID, User_ID, Doctor_ID, Slot_ID,  
     - Статус (Активна, Перенесена, Отменена, Выполнена).

2. **Перенос**  
   - Изменение Slot_ID, если система позволяет перенос на другой слот.  
   - Проверка, что новый слот свободен и принадлежт нужному врачу (или другому — если мы такое разрашаем).

3. **Отмена**  
   - Изменение статуса Appointment на *Отменен*.  
   - Слот становится свободным.

### 2.4 Уведомления о предстоящих приемах.

1. Типы уведомлений:
   - E-mail, SMS, push-уведомления (В мобильном приложении).  
   - Уведомление за N дней/часов до приема (Можно дать выбор пользователю), повторное за M минут.
     
2. Технологии:
   - Брокер сообщения (RabbitMQ, Kafka) для аснхронной отправки сообщений в микросервисе «Notifications Service».  
   - Внешние провайдеры отправки писем (MailChimp, Twilio... любой) для Email / SMS.

3. Гибкие настройки:
   - Возможность отключения SMS / Email / push.

### 2.5 Ведение карточки пациента с историей приемов.

1. Patient_Card:
   - История приемов: дата визита, принимаемый врач, жалобы, диагноз, назначенные лекарства и прочее.
   - Тонкие вопросы безопасности: кто и в каком объеме может видеть эти данные.

2. Статус данных:
   - Сохранение черновых данных (врач может редактировать карту во время приема).  
   - Утвержденные записи (их конечная версия).

---

## 3. Нефункциональные требования.

### 3.1 Поддержка 10 тыс. пользователей в реальном времени.

1. Масштабирование:
   - Использование контейнеров (Docker + Kubernetes) для горизонтального масштабирования микросервисов.  
   - Использовать горизонтальное автомасштабирование (HPA), основываясь на разных метриках (использование CPU, RAM, длина очередей сообщений и подобное). 
   - При больших нагрузках на чтение данных: Read_Replicas (для SQL) или шардирование (для NoSQL).

2. Кэширование:
   - Redis или Memcached для хранения часто запрашиваемых данных (расписания, списки врачей).  
   - Придерживаться Cache aside / Read-Through стратегий, так как точно будут данные, который будут запрашиваться очень часто.

3. Балансировка нагрузки:
   - Nginx (или Kubernetes Ingress) для распределения запросов.

### 3.2 Шифрование данных о пользователях.

1. Безопасность при передаче:
   - Все внешние запросы — HTTPS.  
   - Если Kubernetes – Ingress с TLS-сертификатом.

2. Безопасность при хранении:
   - Пароли: только в виде хэша.  
   - Чувствительные данные (паспорт, адрес, личные данные): шифрование на уровне СУБД или на уровне приложения.  
   - Токены: хранить в защищенных куки или локальном хранилище. На сервере – проверять токен и смотреть на срок его жизни.

3. Хранение мед. данных:
   - При необходимости соответствовать требованиям хранения медицинским данным (есть почти в каждой стране) — следовать их принципам хранения и обработки медицинских данных.

---

## 4. Выбор технологий.

Здесь мы выбираем стек, подходящий для микросервисной архитектуры:

1. Бэкэнд:
   - Язык: Java / Kotlin / Go / Python.  
   - Фреймворк:  
     - Go - стандартная библиотека;  
     - Python — FastAPI или Django.  
   - Микросервисы общаются через Async Messaging (RabbitMQ, Kafka).

2. Базы данных:
   - Реляционная (PostgreSQL, PostgreSQL) — для хранения транзакционных данных (пользователи, бронирования, записи).  
   - NoSQL (MongoDB, Redis) — для высокопроизводительного чтения или хранения временных данных (кэш, сессии, статистика).

3. API_Gateway:
   - Kong / Nginx Ingress Controller в Kubernetes.

4. CI / CD:
   - GitHub Actions, Registry + Kubernetes для автоматической сборки.

5. UI / Фронтэнд:
   - Веб-приложение (React, Angular, Vue) или мобильные приложения (iOS / Android) с обращением к API_Gateway.

6. Сбор данных, мониторинг:
   - Logging (Elasticsearch + Logstash + Kibana).  
   - Monitoring (Prometheus + Grafana). 

---

## 5. Стратегия масштабирования.

1. Горизонтальное масштабирование.
   - Каждый микросервис развертывается в Kubernetes.  
   - Увеличение количества подов в зависимости от нагрузки.

2. Использование раздельных кластеров БД.  
   - К примеру, для особо важных сервисов (Scheduling, Patient_Card) может быть своя отдельная база данных.  

3. Кэширование.
   - Шардирование (через Redis, к примеру) данных, требующих быстрого доступа (слоты расписания, врачи).

---

## 6. Тестирование на нагрузки.

### 6.1 Типы нагрузочных тестов.

1. Load Testing.
   - Постепенно увеличиваем число пользователей до запланированного числа пользователей (10 тысяч активных пользователей).  
   - Смотрим время отклика, процент успешных запросов, использование ресурсов машины.

2. Stress Testing.
   - Продолжаем увеличивать нагрузку, превышающую запланированную норму, пока не достигнем точки отказа системы.
   - Смотрим, как система восстанавливается.

3. Spike Testing.
   - Проблим резко нагрузить систему (К примеру, пользоатели зашли на сервис после массовая рассылка).  
   - Смотрим, не «падает» ли система, тестируем как работает авто-масштабирование.

4. Soak Testing (Длительное тестирование).
   - Запускаем систему под стабильной нагрузкой в течение длительного периода (пусть несколько суток).  
   - Проверяем стабильность работы.

### 6.2 Инструменты для тестирования.

- JMeter / Gatling — для генерации запросов.

---

## 7. Шаблоны проектирования (которые удалось найти).

1. **CQRS (Command Query Responsibility Segregation).**  
   - Разделение модели на часть для чтения и часть для записи.  
   - Полезно, к примеру, в сервсе «Scheduling»:  
     - Запросы к календарю.
     - Изменение слотов — отдельный процесс с проверкой доступности, блокировкой слота и прочее.

2. **Repository/Unit_Of_Work** (внутри каждого микросервиса).
   - Классические паттерны DDD для работы с БД.

---

## 8. Что получаем в итоге?

- **Функциональность**  
  Получаем хороший функционал.

- **Надежность**  
  Сервис надежен, реалезуется использованием микросервисной архитектуры, брокера сообщений (RabbitMQ / Kafka), средств мониторинга.

- **Безопасность**  
  Сервис безопасен. Есть шифрование данных, HTTPS, хеширование паролей, разграничение доступа по ролям.

- **Масштабируемость**  
  Серсвис быстро и легко ма штабируется засчет развертывание в Kubernetes, возможности горизонтального масштабирования подов сервисов и дополнительных реплик БД.

- **Тестирование**  
  Проведено многоуровневое тестирование (юнит, интеграционное, нагрузочное, стрессовое).


> **That's All.**
